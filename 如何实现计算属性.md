# 计算属性

## computed

在平时的开发中，我们都使用过计算属性，在react中没有这种方法，通常我们都可以自己定义一个方法来模拟一个计算属性，也可以在vue中定义method中模拟方法来实现这种功能，但vue为什么要来专门定义这么一个api来帮我们实现功能呢。我们先来看一下代码实现。

```js
// 初始化计算属性
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    // 定义计算watcher
    watchers[key] = new Watcher(
      vm,
      getter || noop,
      noop,
      computedWatcherOptions // {lazy: true} 表明需要惰性求值
    )
    defineComputed(vm, key, userDef)
  }
}
// 定义计算属性
export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  sharedPropertyDefinition.get = createComputedGetter(key) // 定义get时触发函数
  sharedPropertyDefinition.set = noop
  Object.defineProperty(target, key, sharedPropertyDefinition) // 在实例上定义属性对象
}
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate() // 执行计算过程
      }
      if (Dep.target) { // 将计算依赖推入到渲染Watcher
        watcher.depend()
      }
      return watcher.value // 返回计算的值
    }
  }
}
```

通过上边可以看到，computed实际上对应一个watcher实例，我们定义的方法就相当于watcher执行的回调函数。computed有一个特性就是在初始化的时候不会执行，而是在第一次使用的时候才会使用。dirty属性是computed特有的如果为true才会重新进行计算，每次我们计算完一次都会将这个值变成false。

1. 什么时机会执行computed，在执行渲染的时候会使用到computed定义的值，也是会触发get方法，这里会收集相关的依赖，我们使用到的属性都会加入到computedWathcer的dep中，这样当依赖改变的时候才会触发重新计算。

2. 当依赖属性没有改变的时候dirty为false，也不会进行更新，还有当属性改变，但计算结果相同也不会进行更新，这大大提高了渲染的效率


