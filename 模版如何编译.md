# 带你理解 VUE 原理

[模版如何编译](#模版如何编译)

我们来实现一个类似 Vue 的框架，我这里命名为 `W`，我们先来看一下主要的执行流程，然后再深入到每一个细节去看，当我们使用 vue 的时候，通常是直接实例化一个类，我们也直接定义一个类，并在构造方法中初始化传入的参数,执行\_init 方法,`initState`可以看到我们会对传入的数据和方法进行处理，将数据变成双向绑定的数据，将方法挂载到实例上，方便模版生成的方法调用。`initRender`帮我们在全局挂载一些，模版生成代码阶段提供的一些方法。最后我们就会执行`mount`方法将模版代码挂载到传入的`dom`元素上,我们在这个方法中，主要就是将`template`转化成`render`方法。下边是我们构造的 W 类的代码。

新建一个文件 W.ts,用于主类 W 的编写

```ts
// W.ts
class W {
  static uid: number = 0; // 全局递增属性
  static _extend: Function = _extend;
  static component: Function = registerComponent;
  static cid: number = 0; // 用来记录自组件的id
  static options; // 全局的属性
  _uid: number; // 用来记录每一个实例
  _options: WOptions; // 配置对象
  _isW: boolean; // 防止自身被观察
  _data: object; // 私有的data变量用来代理数据使用
  _watchers: Watcher[]; // 存放所有观查器
  _watcher: Watcher; // 当前实例的渲染Watcher
  _createElement: Function; // 生成vnode的方法
  _el: Element; // 当前的挂载dom元素
  _vnode: VNode; // 当前的vnode元素
  _c: Function;
  constructor(options: WOptions) {
    this._init(options);
  }
  /**初始化方法 */
  _init(options) {
    this._uid = W.uid++;
    this._options = options;
    this._isW = true;
    this._watchers = [];
    initState(this); // 初始化数据
    initRender(this); // 初始化渲染相关方法
    if (options.el) {
      this._mount(options.el); // 执行dom挂载
    }
  }
  _mount(el: string) {
    const dom = query(el);
    this._el = dom;
    let updateComponent;
    let { render, template } = this._options;
    // TODO 增加模版编译，目前只支持render方法
    if (!render) {
      if (template) {
        this._options.render = new Compile(
          this,
          template.replace(/(^\s*)|[\r\n]|(\s*$)/g, "") // 过滤掉字符串中的换行和首位空格
        ).render;
      }
    }
    updateComponent = () => {
      // Wathcher监测到数据变化后的渲染方法
      this._update(this._render()); // 根据render方法
    };
    this._watcher = new Watcher(this, updateComponent, noop); // 实例化负责渲染的watcher
  }
  /**将节点更新到dom上 */
  _update(vnode: VNode) {
    const w = this;
    const preVNode = w._vnode;
    w._vnode = vnode;
    /**如果之前没有vnode */
    if (!preVNode) {
      w._el = w._patch(null, vnode, w._el);
    } else {
      w._el = w._patch(preVNode, vnode);
    }
  }
  /**根据render函数生成vnode */
  _render() {
    const { render } = this._options;
    let html: VNode;
    try {
      html = render.call(this, this._createElement);
    } catch (error) {
      warn(`render error:${error}`);
    }
    return html;
  }
  /**对比vnode生成dom元素 */
  _patch(oldVNode: VNode, vnode: VNode, oldElemet?: Element): Element {
    return patch(oldVNode, vnode, oldElemet);
  }
}
```

## 模版如何编译

说到 vue 的原理一般都会从响应式原理说起，编译这里虽然复杂，但理解了这里会对框架整个的渲染过程有深入的了解，所以我从这里开始，使我们能对后面的功能有更深入的理解。我们在用 vue 时我们都会在 template 中写模版，这里就需要一个从模版到渲染方法的过程。熟悉 jsx 的应该知道，jsx 最后编译成形如`createElemt('div',{class: 'demo'}, createElement('div',{},null))`这样一个方法，createElemt 是生成一个 dom 节点的方法，这样实际上就是将模版传化成了一个多叉树的形状。

### 浏览器如何解析 html

上边说到会讲 template 最终解析成一个能生成 dom 树的 render 方法，其实浏览器再渲染 html 时也是使用这种方法这不过更复杂，vue 模版编译其实也是借用了浏览器解析 html 生成 dom 树的这个过程，利用栈的数据结构一步步遍历 html 字符串，建立起一棵 dom 树。

### compile 方法的主要思想

学过编译原理的应该知道，编译原理简单来说，词法分析-》语法分析-》生成抽象语法树-》代码优化-》代码生成。中间还有很多环节，这里我们不是编译源码只是将模版字符串转化成其实可以理解成一个树形状的代码。我们只需要上边的后 3 步。我们来新建一个文件 compile/index.js

```ts
/**负责模版编译 */
class Compile {
  _w: W;
  _template: string;
  render: Function;
  constructor(w: W, template: string) {
    this._w = w; // 保存当前实例
    this._template = template; // 保存当前模版
    this._init();
  }
  _init() {
    // 生成抽象语法树
    const ast = parse(this._template);
    console.log(ast);
    // 优化语法树
    this.optimize(ast);
    // 代码生成
    const code = generate(ast);
    // 通过字符串生成render函数
    this.render = new Function(code.render);
    console.log(code);
  }
  /**
   * 主要是对语法树的优化将不会变化的节点标记成static
   * 例如class这种不会变得属性
   * 深度优先遍历只要子节点不是静态的那么父节点也不是
   * @param ast
   */
  private optimize(ast: AstElement) {
    if (!ast) return;
    isStaticKey = makeMap(
      "type,tag,attrsList,attrsMap,plain,parent,children,attrs,staticClass,staticStyle"
    );
    this.markStatic(ast); // 标记每一个节点是不是静态节点
    this.markStaticRoot(ast); // 标记根节点是不是静态根节点
  }
  markStatic(node) {
    node.static = this.isStatic(node);
    if (node.type === 1) {
      // 如果是HTMlELEMENT元素
      node.children.forEach(child => {
        this.markStatic(child);
        if (!child.static) {
          node.static = false;
        }
      });
    }
  }
  markStaticRoot(node) {
    if (node.type === 1) {
      if (
        node.static &&
        node.children.length &&
        !(node.children.length === 1 && node.children[0].type === 3)
      ) {
        node.staicRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        node.children.forEach(child => {
          this.markStaticRoot(child);
        });
      }
    }
  }
  isStatic(node) {
    // 判断是不是静态标签，就是没有vue数据绑定相关的代码
    if (node.type === 2) {
      // 表达式
      return false;
    } else if (node.type === 3) {
      // 表示文本节点text
      return true;
    }
    return !node.if && !node.for && !node.hasBindings;
  }
}
```

我们可以看到执行`init`方法其实就是执行，执行上边编译成 dom 生成树方法需要的 3 步，我们先来看第一步生成语法树的过程

1. parse 生成语法树

由于 vue 目前可以编译 web 平台也可以编译成 weex 客户端平台的代码，所以源码中很多编译的方法都是通过参数的方式传入，我们这里不这样做，我们只是编译成 web 平台的代码，没必要增加复杂度，大体结构与源码一致。在这里我们实现一些基本的功能`v-if, v-for,v-bind,@click`

这个过程主要利用栈的数据结构来存贮我们自定义的`AstElement`结构的元素。

我们先来看一看这种类型的数据结构

```ts
interface AstElement extends Object {
  type: number; // 存贮元素的类型与HtmlELement的type几乎一样
  tag: string; // 存贮元素的标签名
  attrsList: WObject[]; // 存贮属性列表
  attrsMap: Object; // 存贮属性的map
  parent: AstElement | null; // 当前父元素
  children: AstElement[]; // 子元素
  hasBindings?: boolean; // 是否是v-bind元素
  if?: any; // 是否有v-if元素
  ifConditions?: any[]; // if的条件表达式
  else?: any; // v-else
  elseif?: any; // v-elseif
  for?: any; // 是否有for循环
  alias?: any;
  iterator1?: any; // 是否有迭代器
  events?: any; // 事件绑定
  staticClass?: string; // 静态class
  plain?: boolean; // 是否是占位元素
  key?: any; // key值
  forProcessed?: boolean;
  ifProcessed?: boolean;
}
```

parse 的过程主要涉及标签的识别，我们要把字符串中特殊标签，进行匹配,下边列出了如何匹配各种 html 标签

例如：

1. 开始标签`<div`
2. 开始结束标签 `/>`
3. 匹配属性的 key 和 value `name="abc"`

匹配到了属性值，有一些特殊的属性值需要与 vue 中相关的数据绑定

例如

1. 各种指令`v-if，v-for，v-bind`
2. 事件绑定相关的`v-on`

```ts
// 关于html字符串的匹配
const tagName = "([a-zA-Z_][\\w\\-\\.]*)"; // 匹配以字母_开头和任意单词组合的标签名
const startTagOpen = new RegExp(`^<${tagName}`); // 捕获开始标签 <div
const startTagClose = /^\s*(\/?)>/; // 开始标签结束 />
const endTag = new RegExp(`^<\\/${tagName}[^>]*>`); // 结束标签 </div>
const attrIdentifier = /([^\s"'<>/=]+)/; // 属性标识
const attrAssgin = /(?:=)/; // 属性=
const attrValues = [
  /"([^"]*)"+/.source, // "abc"
  /'([^']*)'+/.source, // 'abc'
  /([^\s"'=<>']+)/.source // 除了一些特殊值外的任意值
];
// 属性值 name="abc"
const attrReg = new RegExp(
  `^\\s*${attrIdentifier.source}(?:\\s*(${
    attrAssgin.source
  }))\\s*(?:${attrValues.join("|")})`
);

// 关于属性值的匹配
const forAliasRE = /(.*?)\s+(?:in)\s+(.*)/; // 例如item in list  ["item in list", "item", "list", index: 0, input: "item in list", groups: undefined]
const forIteratorRE = /\(([^,]*),([^,]*)\)/; // 匹配 (item, index) ["(item, index)", "item", " index", index: 0, input: "(item, index)", groups: undefined]
const textRE = /\{\{((?:.|\r?\n)+?)\}\}/g; // {{name}}
const dirRE = /^w-|^@|^:/ // w-|@|:
const bindRE = /^w-bind:|^:/ // w-bind:|:
const onRE = /^@|^w-on:/ // @|w-on:
```

我们有了上边一些列正则就能获取 template 字符串中一些关键标签和属性，我们来看看是如何将字符串转为模版的，

```ts
/**
 * 对html字符串进行编译
 * @param html
 */
export function parse(html) {
  let stack = [], // 用来保存ast节点的栈
    root, // 树的根节点
    currentParent; // 当前的父节点
  parseHtml(html, start, end, chars); // 匹配模版字符串
  return root;
  /**
   * 对开始标签的处理
   * @param tag // 标签名
   * @param attrs // 属性
   * @param unary // 是不是自闭合标签
   */
  function start(tag, attrs, unary) {
    // 初始化ast元素
    const element: AstElement = {
      type: 1,
      tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      parent: currentParent,
      children: []
    };
    // 对key的处理
    processKey(element);
    // 对w-for的处理
    processFor(element);
    // 对w-if的处理
    processIf(element);
    element.plain = !element.key && !element.attrsList.length;
    // 对class的处理
    processClass(element);
    // 对其他属性的处理
    processAttr(element);
    // 定义树根
    if (!root) {
      root = element;
    }
    // 如果设置过父节点，定义父子关系
    if (currentParent) {
      currentParent.children.push(element);
      element.parent = currentParent;
    }
    if (!unary) {
      currentParent = element;
      stack.push(element);
    }
  }
  /**
   * 对结束标签的处理
   * 出栈并设置父节点
   */
  function end() {
    stack.length -= 1;
    currentParent = stack[stack.length - 1];
  }
  /**
   * 对文本节点的处理
   */
  function chars(text: string) {
    if (!currentParent) return;
    let children = currentParent.children;
    if (text) {
      let exp;
      if (text !== " " && (exp = parseText(text))) {
        children.push({
          type: 2,
          expression: exp.expression,
          tokens: exp.tokens,
          text
        });
      } else if (text !== " " || !children.length) {
        children.push({
          type: 3,
          text
        });
      }
    }
  }
  function makeAttrsMap(attrs: any[]) {
    const map = {};
    attrs.forEach(attr => {
      map[attr.name] = attr.value;
    });
    return map;
  }
  function parseText(text): any {
    if (!textRE.test(text)) return false;
    let tokens = [],
      rowTokens = [],
      lastIndex = (textRE.lastIndex = 0), // 上一次索引
      match,
      index,
      tokenValue,
      exp;
    while ((match = textRE.exec(text))) {
      index = match.index;
      // 匹配位置大于上次的位置说明中间有text文本
      if (index > lastIndex) {
        rowTokens.push((tokenValue = text.slice(lastIndex, index)));
        tokens.push(JSON.stringify(tokenValue));
      }
      exp = match[1].trim();
      tokens.push(`_s(${exp})`);
      rowTokens.push({ "@binding": exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      tokens.push((tokenValue = text.slice(lastIndex)));
      rowTokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join("+"),
      tokens: rowTokens
    };
  }
  /**处理for指令 */
  function processFor(el: AstElement) {
    let exp = getRemoveAttr(el, "w-for");
    if (exp) {
      const inMatch = exp.match(forAliasRE);
      el.for = inMatch[2];
      const alias = inMatch[1];
      const interatorMatch = alias.match(forIteratorRE);
      if (interatorMatch) {
        el.alias = interatorMatch[1].trim();
        el.iterator1 = interatorMatch[2].trim();
      } else {
        el.alias = alias;
      }
    }
  }
  /**处理if指令 */
  function processIf(el: AstElement) {
    let exp = getRemoveAttr(el, "w-if");
    if (exp) {
      el.if = exp;
      if (!el.ifConditions) {
        el.ifConditions = [];
      }
      el.ifConditions.push({
        exp,
        block: el
      });
    } else {
      if (getRemoveAttr(el, "w-else") != null) {
        el.else = true;
      }
      const elseif = getRemoveAttr(el, "w-else-if");
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }
  function processClass(el: AstElement) {
    let staticClass = getRemoveAttr(el, "class");
    if (staticClass) {
      el.staticClass = staticClass;
    }
  }
  function processKey(el: AstElement) {
    let exp = getRemoveAttr(el, "key");
    if (exp) {
      el.key = exp;
    }
  }
  /**处理其他attr属性 */
  function processAttr(el: AstElement) {
    let list = el.attrsList;
    for (let i = 0; i < list.length; i++) {
      let { name, value } = list[i];
      if (dirRE.test(name)) {
        el.hasBindings = true;
        // 匹配到on事件绑定
        if (onRE.test(name)) {
          name = name.replace(onRE, "");
          addHandler(el, name, value);
        } else if (bindRE.test(name)) {
          // 匹配到属性绑定
        }
      }
    }
  }
  // 增加事件
  function addHandler(el: AstElement, name: string, value: string) {
    let events;
    events = el.events || (el.events = {});
    let newHandler = {
      value: value.trim()
    };
    let handlers = events[name];
    if (Array.isArray(handlers)) {
      handlers.push(newHandler);
    } else if (handlers) {
      events[name] = [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }
    el.plain = false;
  }
}

/**
 * 处理html字符串生成抽象语法书
 * @param html
 */
export function parseHtml(
  html: string,
  start: Function,
  end: Function,
  chars: Function
) {
  let index = 0, // 标记字符串位置
    stack = []; // 用来存放匹配的标签寻找父子关系
  while (html) {
    let textEnd = html.indexOf("<");
    let startTagMatch, endTagMatch;
    if (textEnd === 0) {
      /**匹配到结束标签 */
      endTagMatch = html.match(endTag);
      if (endTagMatch) {
        advance(endTagMatch[0].length);
        parseEndTag(endTagMatch[1]);
        continue;
      }
      /**匹配到开始标签 */
      startTagMatch = parseStartTag();
      if (startTagMatch) {
        handleStartTag(startTagMatch);
        continue;
      }
    }
    let rest, text, next;
    /**说明有非标签的元素要处理 */
    if (textEnd > 0) {
      rest = html.slice(textEnd);
      while (!endTag.test(rest) && !startTagOpen.test(rest)) {
        next = rest.indexOf("<", 1);
        if (next < 0) break;
        textEnd += next;
        rest = html.slice(textEnd);
      }
      text = html.substring(0, textEnd);
      advance(textEnd);
    }
    /**没有标签直接当文本处理 */
    if (textEnd < 0) {
      text = html;
      html = "";
    }
    if (text) {
      chars(text);
    }
  }
  /**处理结束tag */
  function parseEndTag(tag) {
    // if((stack[stack.length-1].tag)!= tag){
    //   warn(`${tag} is parse error`)
    // }
    end();
  }
  /**处理开始标签 */
  function parseStartTag() {
    /**匹配起始标签取出tag */
    let start = html.match(startTagOpen);
    let end, attr, match;
    if (start) {
      match = {
        tagName: start[1],
        start: index,
        attrs: []
      };
      advance(start[0].length);
    }
    /**当不是结束标签时取出attr */
    while (!(end = html.match(startTagClose)) && (attr = html.match(attrReg))) {
      attr.start = index;
      advance(attr[0].length);
      attr.end = index;
      match.attrs.push(attr);
    }
    if (end) {
      match.unarySlash = end[1];
      advance(end[0].length);
      match.end = index;
      return match;
    }
  }
  /**处理开始标签 */
  function handleStartTag(match: WObject) {
    let { tagName, unarySlash, attrs } = match;
    for (let i = 0; i < attrs.length; i++) {
      const args = attrs[i];
      attrs[i] = {
        name: args[1],
        value: args[3] || args[4] || args[5] || "",
        start: args.start + args[0].match(/\s*/).length,
        end: args.end
      };
    }
    let unary = isUnaryTag(tagName);
    if (!unary) {
      stack.push({ tag: tagName, attrs: attrs });
    }
    start(tagName, attrs, unary);
  }
  /**处理完字符串，向前移动 */
  function advance(n: number) {
    index += n;
    html = html.substring(n);
  }
}
```

我们用一个例子来看

```html
<div>
  <div w-if="isShow" @click="clickLi">这是w-if内容</div>
  <div>{{person.name}}</div>
</div>
```

  1. 我们传入的是一个模版字符串，我们会有定义一个stack数组来帮我们维护标签的父子级关系，定义一个currentParent来存贮当前父节点，定义一个root，来保存整个树的根

  2. 我们遍历这个字符串先匹配是否有`<`,如果是在第一个位置说明我们在处理一个开始标签或者一个结束标签。我们先遇到的是`<div` 由于没有属性我们直接走start方法来生成一个`AstElement`元素，并把当前元素放入栈中，维护当前的父元素currentParent。我们接下来匹配又匹配一个`<`开头的标签，并读取所有的属性放入attrsList中方便查找，并把这个tag是div的`AstElement`元素推入栈，并且将第二个div元素放入第一个的children中，并把currentParent指向当前遍历到的元素，这里有w-if指令，和事件绑定@click都会有相关的方法去处理并将`AstElement`的if属性和events属性赋值。

  3. 接下来我们往下遍历还是查看`<`,这里是获取的索引要大于0说明有非标签元素要处理，如果不是结束标签，或者下一个开始标签，我们就把所有的当作文本标签处理，并把文本添加到当前的`currentParent`的children中。

  4. 接下来再匹配，这次我们匹配到的是一个结束标签，这里我们需要做的就是出栈处理，并将`currentParent`重置为最后一个栈顶元素

  5. 继续匹配也是匹配到一个div的`AstElement`元素，再处理文本元素时会检测是不是`{{name}}`这种双向绑定的，如果是把文本标签处理成下边这样

```js
type: 2
expression: "_s(person.name)"
tokens: Array(1)
  0: {@binding: "person.name"}
  length: 1
  __proto__: Array(0)
text: "{{person.name}}"
static: false
```

处理完后，继续匹配到结束标签，重复之前结束标签的处理，这样一颗抽象语法树就生成了

2. 代码优化

做到这里，我们已经完成编译的大部分工作，接下来是语法树优化的阶段，我们要找出其中和vue双向数据绑定无关的内容，并加上static属性方便我们再更新dom的时候直接跳过比对，这里很简单就是树的遍历，不做过多说明了

3. 代码生成阶段

到这里我们已经到了编译的最后一个阶段，将语法树变成我们可以执行的render函数，我们可以看下

```ts
/**
 * 生成代码片段
 * @param el
 */
function genElement(el:AstElement){
  if(el.for && !el.forProcessed){
    return genFor(el)
  }else if(el.if && !el.ifProcessed){
    return genIf(el)
  }else{
    let code
    const data = el.plain ? undefined : genData(el)
    const children = genChildren(el, true)
    code = `_c('${el.tag}'${
      data ? `,${data}` : ''
    }${children ? `,${children}` : ''})`
    return code
  }
}

function genFor(el:AstElement){
  const exp = el.for
  const alias = el.alias
  const iterator1 = el.iterator1 ? `,${el.iterator1}` : ''
  // 防止被重复标记
  el.forProcessed = true
  return `_l((${exp}),` +
    `function(${alias}${iterator1}){` +
      `return ${genElement(el)}` +
    '})'
}
function genIf(el:AstElement){
  el.ifProcessed = true
  return genIfConditions(el.ifConditions.slice())
}
function genIfConditions(conditions){
  if(!conditions.length){
    return '_e()'
  }
  const condition = conditions.shift()
  if(condition.exp){
    return `(${condition.exp})?${genTeranaryExp(condition.block)}:${genIfConditions(conditions)}`
  }else{
    return `${genTeranaryExp(condition.block)}`
  }
}

export function renderMixin(W: Function){
  /**模版渲染辅助方法 */
  W.prototype._v = createTextVNode
  W.prototype._s = toString
  W.prototype._l = renderList
  W.prototype._e = createEmptyElement
}
```

我们可以看到w-if对应的其实就是一个三目运算，`w-for`我们有`_l`渲染函数帮忙处理。这里的逻辑很简单，根据语法树中不同的标记递归的生成代码片段，还有一个问题我们生成了函数，怎样与双向绑定的数据方法关联起来。我们直接使用with方法可以动态绑定上下文中的this`with(this){return ${code} }`。这样我们的render函数就完成了。到这里关于模版编译的解释完了

## 数据如何双向绑定
