# 双向数据如何绑定

前边我们介绍了如何编译模版，在主类中初始化过程中调用了`initState`这个方法就是用来完成双向数据如何绑定的。我理解这里边主要涉及 2 个设计模式，_观察者模式_，_发布订阅模式_。我们主要能劫持数据的修改,对修改做到响应，还要定制观察者，只有我们用到的属性才会触发渲染。所以我们这里必须要有一个观察者对象`Watcher`,还有一个依赖收集对象`Dep`用来保存被使用到的属性。我们先看一下如何劫持数据修改

```ts
function initData(w: W) {
  let data = w._options.data;
  /**对象是引用类型，复用组件时可能会出错，所以可以用函数返回data */
  data = w._data = typeof data === "function" ? data() : data || {};
  for (const key in data) {
    if (data.hasOwnProperty(key)) {
      proxy(w, "_data", key);
    }
  }
  // 双向绑定劫持数据
  observe(data, true);
}
/*通过proxy函数将_data（或者_props等）上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。*/
function proxy(target: W, key: string, sourceKey: string) {
  commonProperty.get = function getProxy() {
    return this[key][sourceKey];
  };
  commonProperty.set = function setProxy(val: any) {
    this[key][sourceKey] = val;
  };
  Object.defineProperty(target, sourceKey, commonProperty);
}
/**
 * 对data数据递归的进行劫持
 * @param data
 * @param isRoot
 */
export function observe(data: WObject, isRoot?: boolean): Observer {
  // 递归的终止条件
  if (!isObject(data)) return;
  let ob: Observer;
  if (hasOwn(data, "__ob__") && data.__ob__ instanceof Observer) {
    ob = data.__ob__;
  } else {
    if ((isArray(data) || isPlainObject(data)) && !data._isW) {
      ob = new Observer(data);
    }
  }
  return ob;
}
```

上边可以看到首先对传入的 data 做了一层代理，我们访问`this.name`实际上是`this._data.name`。然后我们对传入的 data 数据转化为 Observer 对象，这里也用到`Object.defineProperty`帮我们劫持数据。深度遍历数据将所有的*纯对象*都变成响应式数据。

```ts
class Observer {
  value: any;
  dep: Dep;
  constructor(value) {
    this.value = value;
    this.dep = new Dep();
    /**将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了 */
    def(value, "__ob__", this);
    /**
     * 如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。
     * 这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。
     */
    const augment = hasProto ? protoAugment : copyAugment;
    if (isArray(value)) {
      augment(value, arrayMethods);
      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value);
    } else {
      /*如果是对象则直接walk进行绑定*/
      this.walk(value);
    }
  }
  /**
   * 遍历对象定义响应式对象
   * @param value
   */
  walk(value: object) {
    for (const key in value) {
      if (value.hasOwnProperty(key)) {
        defineReactive(value, key, value[key]);
      }
    }
  }
  /**
   * 遍历数组每一项
   * @param array
   */
  observeArray(array: Array<any>) {
    for (let i = 0; i < array.length; i++) {
      observe(array[i]);
    }
  }
}

/*为对象defineProperty上在变化时通知的属性*/
export function defineReactive(target: object, key: string, val: any) {
  const proto = Object.getOwnPropertyDescriptor(target, key);
  if (proto && !proto.configurable) {
    return;
  }
  const dep = new Dep();
  const getter = proto && proto.get;
  const setter = proto && proto.set;
  // 深度遍历target对象直到所有属性都被劫持了数据getter，setter
  let childOb = observe(val);
  Object.defineProperty(target, key, {
    configurable: true,
    enumerable: true,
    get: function() {
      val = getter ? getter.call(target) : val;
      if (Dep.target) {
        /**进行依赖收集将当前dep加入当前Watcher */
        dep.depend();
        if (childOb) {
          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/
          childOb.dep.depend();
        }
        if (isArray(val)) {
          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/
          dependArray(val);
        }
      }
      return val;
    },
    set: function(newVal) {
      const value = getter ? getter.call(target) : val;
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return;
      }
      if (setter) {
        val = setter.call(target, newVal);
      } else {
        val = newVal;
      }
      /*新的值需要重新进行observe，保证数据响应式*/
      childOb = observe(newVal);
      /*dep对象通知所有的观察者*/
      dep.notify();
    }
  });
}

/**递归收集数组的依赖 */
function dependArray(array: any[]) {
  array.forEach(e => {
    /*通过对象上的观察者进行依赖收集*/
    e && e.__ob__ && e.__ob__.dep.depend();
    /*当数组成员还是数组的时候地柜执行该方法继续深层依赖收集，直到是对象为止。*/
    if (isArray(e)) {
      dependArray(e);
    }
  });
}
```

我们深度遍历对象，对数组需要修改数组的`push,slice,unshift`长度的方法进行劫持，需要将新加入的对象也变成 Observer 对象，并且需要触发更新。对于对象最终都会调用`defineReactive`来实现依赖收集和发布。最终我们对 data 的每个属性都使用`Object.defineProperty`定义了。主要功能是对 get 进行劫持进行依赖收集，当触发 set 的时候对收集的依赖进行通知。下边来看下负责观察对象变化 Watcher 和 Dep 这两个类是相互依赖的

```ts
export class Watcher {
  deps: Dep[]; // 上次更新的依赖项
  newDeps: Dep[]; // 当前更新新增加的依赖型
  id: number;
  depIds: Set<number>; // 都是时间换空间的思想用来加快遍历保存dep的id
  newDepIds: Set<number>;
  w: W;
  active: boolean;
  getter: Function;
  value: any;
  sync: boolean;
  cb: Function;
  constructor(w: W, exp: Function, cb: Function, options?: object) {
    this.w = w;
    /*_watchers存放订阅者实例*/
    w._watchers.push(this);
    this.id = wid++;
    this.active = true;
    this.sync = true; // 先不做异步更新默认是同步的
    this.cb = cb;
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();
    this.getter = exp;
    this.value = this.get();
  }
  get() {
    let value;
    pushTarget(this);
    const w = this.w;
    /*
      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。
      在将Dep.target设置为自生观察者实例以后，执行getter操作。
      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，
      那么在执行getter的时候就会触发a跟c两个数据的getter函数，
      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，
      将该观察者对象放入闭包中的Dep的subs中去。
    */
    try {
      value = this.getter.call(w, w);
    } catch (error) {
      warn(`${error} in Watcher get`);
    }
    popTarget();
    // 每次执行之后都要清楚最新的依赖留给下次使用
    this.cleanDeps();
    return value;
  }
  addDep(dep: Dep) {
    const id = dep.id;
    // 防止重复添加
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  }
  cleanDeps() {
    // 对比上次更新的依赖如果最新的依赖没有就移除掉当前Watcher
    for (let i = 0; i < this.deps.length; i++) {
      const dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    // 将最新的依赖和上次更新的依赖交换，保存
    swap(this.depIds, this.newDepIds);
    this.newDepIds.clear();
    swap(this.deps, this.newDeps);
    this.newDeps.length = 0;
  }
  update() {
    if (this.sync) {
      this.run();
    } else {
      // TODO:
    }
  }
  run() {
    if (this.active) {
      const newValue = this.get();
      /**即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */
      if (newValue !== this.value || isObject(newValue)) {
        const oldValue = this.value;
        this.value = newValue;
        this.cb.call(this.w, newValue, oldValue);
      }
    }
  }
  /*收集该watcher的所有deps依赖*/
  depend() {
    this.deps.forEach(dep => {
      dep.depend();
    });
  }
  /*将自身从所有依赖收集订阅列表删除*/
  teardown() {}
}

export class Dep {
  static target?: Watcher
  id: number
  subs: Watcher[]
  constructor() {
    this.id = wid++
    this.subs = []
  }
  addSub(sub: Watcher) {
    this.subs.push(sub)
  }
  removeSub(sub: Watcher) {
    if (this.subs.length) {
      let index = this.subs.indexOf(sub)
      if (index > -1) {
        this.subs.splice(index, 1)
      }
    }
  }
  // 收集依赖
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
  // 通知所有Watcher更新
  notify() {
    const subs = this.subs.slice()
    for (let i = 0; i < subs.length; i++) {
      subs[i].update()
    }
  }
}

/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/
Dep.target = null
const targetStack = []

/*将watcher观察者实例设置给Dep.target，用以依赖收集。同时将该实例存入target栈中*/
export function pushTarget(_target: Watcher) {
  if (Dep.target) {
    targetStack.push(Dep.target)
  }
  Dep.target = _target
}

/*将观察者实例从target栈中取出并设置给Dep.target*/
export function popTarget() {
  Dep.target = targetStack.pop()
}
```

1. 首先来看Dep类，主要就两个方法depend负责收集依赖，Dep.target指向的是一个全局的Watcher（由于可能会有多个Watcher），因为Watcher不光用来渲染dom，notify将收集来的Watcher都触发更新。

2. 再来看看Watcher类，get方法会收集传入的方法执行时用到的数据，这就做到了依赖收集，dep是用来存贮依赖的。当Watcher监测到数据变化就会触发更新的逻辑，这里有一个清除依赖的逻辑，比如说我用了v-if,当条件是false的时候，我们之前监测的一些数据就不需要了，我们要删除这些依赖，因为变化不会显示在dom上。这里也用到了一个栈来维持当前全局变量指向的Watcher，这样在能保证在嵌套触发的时候，全局的Watcher不会出错。

这样关于双向绑定的基本上就说完了。
